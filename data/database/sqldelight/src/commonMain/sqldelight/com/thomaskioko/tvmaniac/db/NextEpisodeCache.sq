import com.thomaskioko.tvmaniac.db.Id;
import com.thomaskioko.tvmaniac.db.TmdbId;
import com.thomaskioko.tvmaniac.db.EpisodeId;

CREATE TABLE next_episode_cache (
    show_id INTEGER AS Id<TmdbId> PRIMARY KEY,
    episode_id INTEGER AS Id<EpisodeId>,
    episode_name TEXT NOT NULL,
    episode_number INTEGER NOT NULL,
    season_number INTEGER NOT NULL,
    air_date TEXT,
    runtime INTEGER,
    still_path TEXT,
    overview TEXT NOT NULL DEFAULT '',
    is_upcoming INTEGER NOT NULL DEFAULT 0,
    updated_at INTEGER NOT NULL,
    FOREIGN KEY(show_id) REFERENCES tvshow(id) ON DELETE CASCADE
);

-- Queries

upsert:
INSERT OR REPLACE INTO next_episode_cache(
    show_id,
    episode_id,
    episode_name,
    episode_number,
    season_number,
    air_date,
    runtime,
    still_path,
    overview,
    is_upcoming,
    updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);

getNextEpisodeForShow:
SELECT
    nec.*,
    t.name AS show_name,
    t.poster_path AS show_poster
FROM next_episode_cache nec
JOIN tvshow t ON nec.show_id = t.id
WHERE nec.show_id = ?;

getNextEpisodesForWatchlist:
SELECT
    nec.*,
    t.name AS show_name,
    t.poster_path AS show_poster,
    w.created_at AS followed_at
FROM next_episode_cache nec
JOIN tvshow t ON nec.show_id = t.id
JOIN watchlist w ON nec.show_id = w.id
ORDER BY
    CASE
        WHEN nec.is_upcoming = 0 THEN 0
        ELSE 1
    END,
    w.created_at DESC;

getNextEpisodesCount:
SELECT COUNT(*) FROM next_episode_cache nec
JOIN watchlist w ON nec.show_id = w.id;

-- New query: Get next episode using the intelligent view
getNextEpisodeFromView:
SELECT
    e.id AS episode_id,
    e.title AS episode_name,
    e.episode_number,
    s.season_number,
    nec.air_date, -- Use air_date from cache since episode table doesn't have it
    e.runtime,
    e.image_url AS still_path,
    e.overview,
    0 AS is_upcoming, -- Default to not upcoming since we don't track air dates in episode table
    t.id AS show_id,
    t.name AS show_name,
    t.poster_path AS show_poster_path,
    CURRENT_TIMESTAMP AS updated_at
FROM shows_next_to_watch sntw
INNER JOIN episode e ON sntw.episode_id = e.id
INNER JOIN season s ON sntw.season_id = s.id
INNER JOIN tvshow t ON sntw.show_id = t.id
LEFT JOIN next_episode_cache nec ON nec.show_id = t.id
WHERE sntw.show_id = ?;

-- New query: Get all next episodes for watchlist using the view
getNextEpisodesForWatchlistFromView:
SELECT
    e.id AS episode_id,
    e.title AS episode_name,
    e.episode_number,
    s.season_number,
    nec.air_date, -- Use air_date from cache since episode table doesn't have it
    e.runtime,
    e.image_url AS still_path,
    e.overview,
    0 AS is_upcoming, -- Default to not upcoming
    t.id AS show_id,
    t.name AS show_name,
    t.poster_path AS show_poster_path
FROM shows_next_to_watch sntw
INNER JOIN episode e ON sntw.episode_id = e.id
INNER JOIN season s ON sntw.season_id = s.id
INNER JOIN tvshow t ON sntw.show_id = t.id
INNER JOIN watchlist w ON w.id = t.id
LEFT JOIN next_episode_cache nec ON nec.show_id = t.id
ORDER BY s.season_number, e.episode_number;

deleteNextEpisode:
DELETE FROM next_episode_cache
WHERE show_id = ?;

deleteAll:
DELETE FROM next_episode_cache;

-- Get shows that need next episode refresh (older than threshold)
getStaleNextEpisodes:
SELECT show_id FROM next_episode_cache
WHERE updated_at < ?;
