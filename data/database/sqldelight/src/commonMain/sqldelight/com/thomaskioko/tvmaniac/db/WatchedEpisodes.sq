import com.thomaskioko.tvmaniac.db.Id;
import com.thomaskioko.tvmaniac.db.TmdbId;
import com.thomaskioko.tvmaniac.db.EpisodeId;
import kotlin.Boolean;

CREATE TABLE watched_episodes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    show_id INTEGER AS Id<TmdbId> NOT NULL,
    episode_id INTEGER AS Id<EpisodeId> DEFAULT NULL,
    season_number INTEGER NOT NULL,
    episode_number INTEGER NOT NULL,
    watched_at INTEGER NOT NULL,
    trakt_id INTEGER DEFAULT NULL,
    synced_at INTEGER DEFAULT NULL,
    pending_action TEXT NOT NULL,
    FOREIGN KEY(show_id) REFERENCES tvshow(id) ON DELETE CASCADE,
    FOREIGN KEY(episode_id) REFERENCES episode(id) ON DELETE CASCADE,
    UNIQUE(show_id, season_number, episode_number)
);

CREATE INDEX IF NOT EXISTS idx_watched_episodes_show_id ON watched_episodes(show_id);
CREATE INDEX IF NOT EXISTS idx_watched_episodes_show_season ON watched_episodes(show_id, season_number);
CREATE INDEX IF NOT EXISTS idx_watched_episodes_pending_action ON watched_episodes(pending_action);
CREATE INDEX IF NOT EXISTS idx_watched_episodes_trakt ON watched_episodes(trakt_id);

-- Queries

upsert:
INSERT OR REPLACE INTO watched_episodes(
    show_id,
    episode_id,
    season_number,
    episode_number,
    watched_at,
    pending_action
) VALUES (?, ?, ?, ?, ?, ?);

getWatchedEpisodes:
SELECT
    watched_episodes.id AS watched_id,
    watched_episodes.show_id,
    watched_episodes.episode_id,
    watched_episodes.season_number,
    watched_episodes.episode_number,
    watched_episodes.watched_at,
    watched_episodes.trakt_id,
    watched_episodes.synced_at,
    watched_episodes.pending_action
FROM watched_episodes
WHERE show_id = ?
ORDER BY season_number, episode_number;

getWatchedEpisodesForSeason:
SELECT
    watched_episodes.id AS watched_id,
    watched_episodes.show_id,
    watched_episodes.episode_id,
    watched_episodes.season_number,
    watched_episodes.episode_number,
    watched_episodes.watched_at,
    watched_episodes.trakt_id,
    watched_episodes.synced_at,
    watched_episodes.pending_action
FROM watched_episodes
WHERE show_id = ? AND season_number = ?
ORDER BY episode_number;

markAsWatched:
INSERT OR REPLACE INTO watched_episodes(
    show_id, episode_id, season_number, episode_number, watched_at, pending_action
) VALUES (?, ?, ?, ?, ?, ?);

markAsUnwatched:
DELETE FROM watched_episodes
WHERE show_id = ? AND episode_id = ?;

deleteAllForShow:
DELETE FROM watched_episodes
WHERE show_id = ?;

deleteForSeason:
DELETE FROM watched_episodes
WHERE show_id = ? AND season_number = ?;


getTotalEpisodesForSeason:
SELECT COUNT(*) FROM episode e
INNER JOIN season s ON e.season_id = s.id
WHERE e.show_id = ? AND s.season_number = ?
  AND (e.air_date IS NULL OR e.air_date <= date('now'));

getPreviousUnwatchedEpisodes:
SELECT
    e.id AS episode_id,
    s.season_number,
    e.episode_number,
    e.season_id
FROM episode e
INNER JOIN season s ON e.season_id = s.id
LEFT JOIN watched_episodes we ON e.id = we.episode_id AND we.show_id = :show_id
WHERE e.show_id = :show_id
  AND (:include_specials = 1 OR (s.season_number > 0 OR s.title != 'Specials'))
  AND (
    (s.season_number < :season_number)
    OR (s.season_number = :season_number AND e.episode_number < :episode_number)
  )
  AND we.id IS NULL
  AND (e.air_date IS NULL OR e.air_date <= date('now'))
ORDER BY s.season_number, e.episode_number;

getEpisodesForSeason:
SELECT
    e.id AS episode_id,
    s.season_number,
    e.episode_number,
    e.season_id
FROM episode e
INNER JOIN season s ON e.season_id = s.id
WHERE e.show_id = ? AND s.season_number = ?
  AND (e.air_date IS NULL OR e.air_date <= date('now'))
ORDER BY e.episode_number;

getTotalEpisodesForShow:
SELECT COUNT(*) FROM episode
WHERE show_id = ?
  AND (air_date IS NULL OR air_date <= date('now'));

getWatchedEpisodesCountForShow:
SELECT COUNT(*) FROM watched_episodes
WHERE show_id = ?;

getUnwatchedEpisodesInPreviousSeasons:
SELECT
    e.id AS episode_id,
    s.season_number,
    e.episode_number,
    e.season_id
FROM episode e
INNER JOIN season s ON e.season_id = s.id
LEFT JOIN watched_episodes we ON e.id = we.episode_id AND we.show_id = :show_id
WHERE e.show_id = :show_id
  AND s.season_number < :season_number
  AND (:include_specials = 1 OR (s.season_number > 0 OR s.title != 'Specials'))
  AND we.id IS NULL
  AND (e.air_date IS NULL OR e.air_date <= date('now'))
ORDER BY s.season_number, e.episode_number;

getUnwatchedEpisodeCountInPreviousSeasons:
SELECT COUNT(*) FROM episode e
INNER JOIN season s ON e.season_id = s.id
LEFT JOIN watched_episodes we ON e.id = we.episode_id AND we.show_id = :show_id
WHERE e.show_id = :show_id
  AND s.season_number < :season_number
  AND (:include_specials = 1 OR (s.season_number > 0 OR s.title != 'Specials'))
  AND we.id IS NULL
  AND (e.air_date IS NULL OR e.air_date <= date('now'));

-- Trakt Sync Queries

getEntriesByPendingAction:
SELECT
    watched_episodes.id AS watched_id,
    watched_episodes.show_id,
    watched_episodes.episode_id,
    watched_episodes.season_number,
    watched_episodes.episode_number,
    watched_episodes.watched_at,
    watched_episodes.trakt_id,
    watched_episodes.synced_at,
    watched_episodes.pending_action
FROM watched_episodes
WHERE pending_action = ?
ORDER BY watched_at;

updatePendingAction:
UPDATE watched_episodes
SET pending_action = ?
WHERE id = ?;

updatePendingActionByShowAndEpisode:
UPDATE watched_episodes
SET pending_action = ?
WHERE show_id = ? AND episode_id = ?;

deleteById:
DELETE FROM watched_episodes WHERE id = ?;

getEntryByShowAndEpisode:
SELECT
    watched_episodes.id AS watched_id,
    watched_episodes.show_id,
    watched_episodes.episode_id,
    watched_episodes.season_number,
    watched_episodes.episode_number,
    watched_episodes.watched_at,
    watched_episodes.trakt_id,
    watched_episodes.synced_at,
    watched_episodes.pending_action
FROM watched_episodes
WHERE show_id = ? AND episode_id = ?;

upsertFromTrakt:
INSERT OR REPLACE INTO watched_episodes(
    show_id, episode_id, season_number, episode_number, watched_at, trakt_id, synced_at, pending_action
) VALUES (?, ?, ?, ?, ?, ?, ?, ?);

getAllSeasonsWatchProgress:
SELECT
    s.season_number,
    (SELECT COUNT(*) FROM watched_episodes we WHERE we.show_id = :show_id AND we.season_number = s.season_number) AS watched_count,
    (SELECT COUNT(*) FROM episode e WHERE e.show_id = :show_id AND e.season_id = s.id AND (e.air_date IS NULL OR e.air_date <= date('now'))) AS total_count
FROM season s
WHERE s.show_id = :show_id
ORDER BY s.season_number;
