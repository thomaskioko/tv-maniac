import com.thomaskioko.tvmaniac.db.Id;
import com.thomaskioko.tvmaniac.db.TraktId;
import com.thomaskioko.tvmaniac.db.EpisodeId;
import kotlin.Boolean;

CREATE TABLE watched_episodes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    show_trakt_id INTEGER AS Id<TraktId> NOT NULL,
    episode_id INTEGER AS Id<EpisodeId> DEFAULT NULL,
    season_number INTEGER NOT NULL,
    episode_number INTEGER NOT NULL,
    watched_at INTEGER NOT NULL,
    trakt_id INTEGER DEFAULT NULL,
    synced_at INTEGER DEFAULT NULL,
    pending_action TEXT NOT NULL,
    FOREIGN KEY(show_trakt_id) REFERENCES tvshow(trakt_id) ON DELETE CASCADE,
    FOREIGN KEY(episode_id) REFERENCES episode(id) ON DELETE CASCADE,
    UNIQUE(show_trakt_id, season_number, episode_number)
);

CREATE INDEX IF NOT EXISTS idx_watched_episodes_show_trakt_id ON watched_episodes(show_trakt_id);
CREATE INDEX IF NOT EXISTS idx_watched_episodes_show_season ON watched_episodes(show_trakt_id, season_number);
CREATE INDEX IF NOT EXISTS idx_watched_episodes_pending_action ON watched_episodes(pending_action);
CREATE INDEX IF NOT EXISTS idx_watched_episodes_trakt ON watched_episodes(trakt_id);
CREATE INDEX IF NOT EXISTS idx_watched_show_episode ON watched_episodes(show_trakt_id, episode_id);

-- Queries

upsert:
INSERT OR REPLACE INTO watched_episodes(
    show_trakt_id,
    episode_id,
    season_number,
    episode_number,
    watched_at,
    pending_action
) VALUES (?, ?, ?, ?, ?, ?);

getWatchedEpisodes:
SELECT
    watched_episodes.id AS watched_id,
    watched_episodes.show_trakt_id,
    watched_episodes.episode_id,
    watched_episodes.season_number,
    watched_episodes.episode_number,
    watched_episodes.watched_at,
    watched_episodes.trakt_id,
    watched_episodes.synced_at,
    watched_episodes.pending_action
FROM watched_episodes
WHERE show_trakt_id = ?
ORDER BY season_number, episode_number;

getWatchedEpisodesForSeason:
SELECT
    watched_episodes.id AS watched_id,
    watched_episodes.show_trakt_id,
    watched_episodes.episode_id,
    watched_episodes.season_number,
    watched_episodes.episode_number,
    watched_episodes.watched_at,
    watched_episodes.trakt_id,
    watched_episodes.synced_at,
    watched_episodes.pending_action
FROM watched_episodes
WHERE show_trakt_id = ? AND season_number = ?
ORDER BY episode_number;

markAsWatched:
INSERT OR REPLACE INTO watched_episodes(
    show_trakt_id, episode_id, season_number, episode_number, watched_at, pending_action
) VALUES (?, ?, ?, ?, ?, ?);

markAsUnwatched:
DELETE FROM watched_episodes
WHERE show_trakt_id = ? AND episode_id = ?;

deleteAllForShow:
DELETE FROM watched_episodes
WHERE show_trakt_id = ?;

deleteForSeason:
DELETE FROM watched_episodes
WHERE show_trakt_id = ? AND season_number = ?;


getTotalEpisodesForSeason:
SELECT COUNT(*) FROM episode e
INNER JOIN season s ON e.season_id = s.id
WHERE e.show_trakt_id = ? AND s.season_number = ?
  AND (e.first_aired IS NULL OR e.first_aired <= date('now'));

getPreviousUnwatchedEpisodes:
SELECT
    e.id AS episode_id,
    s.season_number,
    e.episode_number,
    e.season_id
FROM episode e
INNER JOIN season s ON e.season_id = s.id
LEFT JOIN watched_episodes we ON e.id = we.episode_id AND we.show_trakt_id = :show_trakt_id
WHERE e.show_trakt_id = :show_trakt_id
  AND (:include_specials = 1 OR (s.season_number > 0 OR s.title != 'Specials'))
  AND (
    (s.season_number < :season_number)
    OR (s.season_number = :season_number AND e.episode_number < :episode_number)
  )
  AND we.id IS NULL
  AND (e.first_aired IS NULL OR e.first_aired <= date('now'))
ORDER BY s.season_number, e.episode_number;

getEpisodesForSeason:
SELECT
    e.id AS episode_id,
    s.season_number,
    e.episode_number,
    e.season_id
FROM episode e
INNER JOIN season s ON e.season_id = s.id
WHERE e.show_trakt_id = ? AND s.season_number = ?
  AND (e.first_aired IS NULL OR e.first_aired <= date('now'))
ORDER BY e.episode_number;

getTotalEpisodesForShow:
SELECT COALESCE(SUM(episode_count), 0) AS total
FROM season
WHERE show_trakt_id = :show_trakt_id
  AND (season_number > 0 OR title != 'Specials');

getWatchedEpisodesCountForShow:
SELECT COUNT(*) FROM watched_episodes
WHERE show_trakt_id = ?;

getUnwatchedEpisodesInPreviousSeasons:
SELECT
    e.id AS episode_id,
    s.season_number,
    e.episode_number,
    e.season_id
FROM episode e
INNER JOIN season s ON e.season_id = s.id
LEFT JOIN watched_episodes we ON e.id = we.episode_id AND we.show_trakt_id = :show_trakt_id
WHERE e.show_trakt_id = :show_trakt_id
  AND s.season_number < :season_number
  AND (:include_specials = 1 OR (s.season_number > 0 OR s.title != 'Specials'))
  AND we.id IS NULL
  AND (e.first_aired IS NULL OR e.first_aired <= date('now'))
ORDER BY s.season_number, e.episode_number;

getUnwatchedEpisodeCountInPreviousSeasons:
SELECT COUNT(*) FROM episode e
INNER JOIN season s ON e.season_id = s.id
LEFT JOIN watched_episodes we ON e.id = we.episode_id AND we.show_trakt_id = :show_trakt_id
WHERE e.show_trakt_id = :show_trakt_id
  AND s.season_number < :season_number
  AND (:include_specials = 1 OR (s.season_number > 0 OR s.title != 'Specials'))
  AND we.id IS NULL
  AND (e.first_aired IS NULL OR e.first_aired <= date('now'));

-- Trakt Sync Queries

getEntriesByPendingAction:
SELECT
    watched_episodes.id AS watched_id,
    watched_episodes.show_trakt_id,
    watched_episodes.episode_id,
    watched_episodes.season_number,
    watched_episodes.episode_number,
    watched_episodes.watched_at,
    watched_episodes.trakt_id,
    watched_episodes.synced_at,
    watched_episodes.pending_action
FROM watched_episodes
WHERE pending_action = ?
ORDER BY watched_at;

updatePendingAction:
UPDATE watched_episodes
SET pending_action = ?
WHERE id = ?;

updatePendingActionByShowAndEpisode:
UPDATE watched_episodes
SET pending_action = ?
WHERE show_trakt_id = ? AND episode_id = ?;

deleteById:
DELETE FROM watched_episodes WHERE id = ?;

getEntryByShowAndEpisode:
SELECT
    watched_episodes.id AS watched_id,
    watched_episodes.show_trakt_id,
    watched_episodes.episode_id,
    watched_episodes.season_number,
    watched_episodes.episode_number,
    watched_episodes.watched_at,
    watched_episodes.trakt_id,
    watched_episodes.synced_at,
    watched_episodes.pending_action
FROM watched_episodes
WHERE show_trakt_id = ? AND episode_id = ?;

upsertFromTrakt:
INSERT OR REPLACE INTO watched_episodes(
    show_trakt_id, episode_id, season_number, episode_number, watched_at, trakt_id, synced_at, pending_action
) VALUES (?, ?, ?, ?, ?, ?, ?, ?);

getAllSeasonsWatchProgress:
SELECT
    s.season_number,
    COALESCE(watched.cnt, 0) AS watched_count,
    COALESCE(total.cnt, 0) AS total_count
FROM season s
LEFT JOIN (
    SELECT season_number, COUNT(*) AS cnt
    FROM watched_episodes
    WHERE show_trakt_id = :show_trakt_id
    GROUP BY season_number
) watched ON watched.season_number = s.season_number
LEFT JOIN (
    SELECT season_id, COUNT(*) AS cnt
    FROM episode
    WHERE show_trakt_id = :show_trakt_id
      AND (first_aired IS NULL OR first_aired <= date('now'))
    GROUP BY season_id
) total ON total.season_id = s.id
WHERE s.show_trakt_id = :show_trakt_id
ORDER BY s.season_number;
