-- Migration 12: Replace sync_status with pending_action for bidirectional episode sync
-- Also makes episode_id nullable to support Trakt sync before local episode data is fetched
-- Uses temp table pattern to preserve existing data

CREATE TABLE watched_episodes_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    show_id INTEGER NOT NULL,
    episode_id INTEGER DEFAULT NULL,
    season_number INTEGER NOT NULL,
    episode_number INTEGER NOT NULL,
    watched_at INTEGER NOT NULL,
    trakt_id INTEGER DEFAULT NULL,
    synced_at INTEGER DEFAULT NULL,
    pending_action TEXT NOT NULL,
    FOREIGN KEY(show_id) REFERENCES tvshow(id) ON DELETE CASCADE,
    FOREIGN KEY(episode_id) REFERENCES episode(id) ON DELETE CASCADE,
    UNIQUE(show_id, season_number, episode_number)
);

INSERT INTO watched_episodes_new (
    id, show_id, episode_id, season_number, episode_number, watched_at,
    trakt_id, synced_at, pending_action
)
SELECT
    id, show_id, episode_id, season_number, episode_number, watched_at,
    trakt_id, synced_at,
    CASE WHEN sync_status = 'synced' THEN 'NOTHING' ELSE 'UPLOAD' END
FROM watched_episodes;

DROP TABLE watched_episodes;

ALTER TABLE watched_episodes_new RENAME TO watched_episodes;

CREATE INDEX IF NOT EXISTS idx_watched_episodes_show_id ON watched_episodes(show_id);
CREATE INDEX IF NOT EXISTS idx_watched_episodes_show_season ON watched_episodes(show_id, season_number);
CREATE INDEX IF NOT EXISTS idx_watched_episodes_pending_action ON watched_episodes(pending_action);
CREATE INDEX IF NOT EXISTS idx_watched_episodes_trakt ON watched_episodes(trakt_id);

-- Recreate views using composable pattern (shows_last_watched referenced by shows_next_to_watch)
DROP VIEW IF EXISTS shows_next_to_watch;
DROP VIEW IF EXISTS shows_last_watched;

CREATE VIEW shows_last_watched AS
SELECT
    tvshow.id AS show_id,
    MAX((1000 * season.season_number) + episode.episode_number) AS last_watched_abs_number,
    MAX(watched_episode.watched_at) AS last_watched_at
FROM tvshow
INNER JOIN season ON tvshow.id = season.show_id
INNER JOIN episode ON episode.season_id = season.id AND episode.show_id = tvshow.id
INNER JOIN watched_episodes AS watched_episode ON watched_episode.show_id = tvshow.id AND watched_episode.episode_id = episode.id
WHERE season.season_number > 0 OR season.title != 'Specials'
GROUP BY tvshow.id;

CREATE VIEW shows_next_to_watch AS
SELECT
    tvshow.id AS show_id,
    episode.id AS episode_id,
    episode.title AS episode_name,
    season.id AS season_id,
    season.season_number,
    episode.episode_number,
    episode.runtime,
    episode.image_url AS still_path,
    episode.overview,
    tvshow.name AS show_name,
    tvshow.poster_path AS show_poster,
    ((1000 * season.season_number) + episode.episode_number) AS next_ep_abs_number,
    episode.air_date,
    last_watched.last_watched_at
FROM tvshow
INNER JOIN season ON tvshow.id = season.show_id
INNER JOIN episode ON episode.season_id = season.id AND episode.show_id = tvshow.id
LEFT JOIN watched_episodes AS watched_episode ON watched_episode.show_id = tvshow.id AND watched_episode.episode_id = episode.id
LEFT JOIN shows_last_watched AS last_watched ON last_watched.show_id = tvshow.id
WHERE (season.season_number > 0 OR (season.season_number = 0 AND season.title != 'Specials'))
  AND watched_episode.episode_id IS NULL
  AND ((1000 * season.season_number) + episode.episode_number) > COALESCE(last_watched.last_watched_abs_number, 0)
  AND (episode.air_date IS NULL OR episode.air_date <= date('now'))
ORDER BY tvshow.id, season.season_number, episode.episode_number;
