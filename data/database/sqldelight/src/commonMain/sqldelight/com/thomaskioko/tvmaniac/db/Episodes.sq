import com.thomaskioko.tvmaniac.db.EpisodeId;
import com.thomaskioko.tvmaniac.db.Id;
import com.thomaskioko.tvmaniac.db.SeasonId;
import com.thomaskioko.tvmaniac.db.TraktId;

CREATE TABLE episode (
    id INTEGER AS Id<EpisodeId> NOT NULL PRIMARY KEY,
    season_id INTEGER AS Id<SeasonId> NOT NULL,
    show_trakt_id INTEGER AS Id<TraktId> NOT NULL,
    episode_number INTEGER NOT NULL,
    title TEXT NOT NULL,
    overview TEXT NOT NULL,
    runtime INTEGER DEFAULT NULL,
    vote_count INTEGER NOT NULL,
    ratings REAL NOT NULL,
    image_url TEXT DEFAULT NULL,
    trakt_id INTEGER DEFAULT NULL,
    first_aired INTEGER DEFAULT NULL,
    FOREIGN KEY(season_id) REFERENCES season(id) ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY(show_trakt_id) REFERENCES tvshow(trakt_id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_episode_trakt_id ON episode(trakt_id);
CREATE INDEX IF NOT EXISTS idx_episode_show_trakt_id ON episode(show_trakt_id);
CREATE INDEX IF NOT EXISTS idx_episode_show_season ON episode(show_trakt_id, season_id);
CREATE INDEX IF NOT EXISTS idx_episode_first_aired ON episode(first_aired);
CREATE INDEX IF NOT EXISTS idx_episode_show_first_aired ON episode(show_trakt_id, first_aired);

upsert:
INSERT OR REPLACE INTO episode(
    id,
    season_id,
    show_trakt_id,
    title,
    overview,
    runtime,
    vote_count,
    ratings,
    episode_number,
    image_url,
    trakt_id,
    first_aired
)
VALUES(?,?,?,?,?,?,?,?,?,?,?,?);

episodeDetails:
SELECT
    episode.id AS episode_id,
    episode.season_id,
    episode.show_trakt_id,
    episode.title,
    episode.overview,
    episode.runtime,
    episode.vote_count,
    episode.ratings,
    episode.episode_number,
    episode.image_url
FROM
    episode
WHERE
    episode.id = ?
ORDER BY
    episode_number ASC;

delete:
DELETE FROM episode WHERE id = ?;

deleteAll:
DELETE FROM episode;

getEpisodeByTraktId:
SELECT
    episode.id AS episode_id,
    episode.season_id,
    episode.show_trakt_id,
    episode.episode_number,
    episode.title,
    episode.overview,
    episode.runtime,
    episode.vote_count,
    episode.ratings,
    episode.image_url,
    episode.trakt_id,
    episode.first_aired
FROM episode WHERE trakt_id = ?;

countEpisodesForShow:
SELECT COUNT(*)
FROM episode
INNER JOIN season ON episode.season_id = season.id
WHERE episode.show_trakt_id = :showTraktId
AND (
    :includeSpecials = 1
    OR (season.season_number > 0 OR season.title != 'Specials')
);

getEpisodeByShowSeasonEpisodeNumber:
SELECT
    episode.id AS episode_id,
    episode.season_id,
    episode.show_trakt_id,
    episode.episode_number,
    episode.title,
    episode.overview,
    episode.runtime,
    episode.vote_count,
    episode.ratings,
    episode.image_url,
    episode.trakt_id,
    episode.first_aired
FROM episode
INNER JOIN season ON episode.season_id = season.id
WHERE episode.show_trakt_id = :showTraktId
  AND season.season_number = :seasonNumber
  AND episode.episode_number = :episodeNumber
LIMIT 1;

updateFirstAired:
UPDATE episode
SET first_aired = :firstAired
WHERE show_trakt_id = :showId
  AND season_id IN (SELECT id FROM season WHERE show_trakt_id = :showId AND season_number = :seasonNumber)
  AND episode_number = :episodeNumber;

upcomingEpisodesFromFollowedShows:
SELECT
    episode.id AS episode_id,
    episode.season_id,
    episode.show_trakt_id,
    episode.episode_number,
    episode.title,
    episode.overview,
    episode.runtime,
    episode.image_url,
    episode.first_aired,
    season.season_number,
    tvshow.name AS show_name,
    tvshow.poster_path AS show_poster
FROM episode
INNER JOIN season ON episode.season_id = season.id
INNER JOIN tvshow ON episode.show_trakt_id = tvshow.trakt_id
INNER JOIN followed_shows ON followed_shows.trakt_id = tvshow.trakt_id
LEFT JOIN watched_episodes ON
    watched_episodes.show_trakt_id = episode.show_trakt_id
    AND watched_episodes.season_number = season.season_number
    AND watched_episodes.episode_number = episode.episode_number
    AND watched_episodes.pending_action != 'DELETE'
WHERE season.season_number > 0
  AND episode.first_aired IS NOT NULL
  AND episode.first_aired > :fromEpoch
  AND episode.first_aired < :toEpoch
  AND watched_episodes.id IS NULL
ORDER BY episode.first_aired ASC;

episodesBySeasonId:
SELECT
    episode.id AS episode_id,
    episode.season_id,
    episode.show_trakt_id,
    episode.episode_number,
    episode.title,
    episode.overview,
    episode.runtime,
    episode.vote_count,
    episode.ratings,
    episode.image_url,
    episode.first_aired,
    CASE WHEN watched_episodes.id IS NOT NULL THEN 1 ELSE 0 END AS is_watched
FROM episode
LEFT OUTER JOIN watched_episodes
    ON watched_episodes.episode_id = episode.id
    AND watched_episodes.show_trakt_id = episode.show_trakt_id
    AND watched_episodes.pending_action != 'DELETE'
WHERE episode.season_id = :seasonId
ORDER BY episode.episode_number ASC;

